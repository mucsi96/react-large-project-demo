"use strict";const sw=self;function sendToClient(e,t){return new Promise((s=>{const n=new MessageChannel;n.port1.onmessage=e=>s(e.data),e.postMessage(t,[n.port2])}))}async function createResponse(e,t){const s=()=>fetch(t),n=await sw.clients.get(e);if(!n)return s();const{url:a,method:r}=t,i=await t.text(),o=getHeaders(t),{type:c,response:d}=await sendToClient(n,{type:"REQUEST",request:{url:a,method:r,body:i,headers:o}});return"MOCK_SUCCESS"!==c?s():new Response(d.body,{status:d.status})}function getHeaders(e){const t={};return e.headers.forEach(((e,s)=>{Array.isArray(t[s])?t[s]=[...t[s],e]:t[s]?t[s]=[t[s],e]:t[s]=e})),t}sw.addEventListener("install",(()=>{sw.skipWaiting()})),sw.addEventListener("activate",(e=>{e.waitUntil(sw.clients.claim())})),sw.addEventListener("fetch",(e=>{const{request:t,clientId:s}=e,{cache:n,mode:a}=t;if(s&&("only-if-cached"!==n||"same-origin"===a)&&t.url.startsWith("http")&&!t.url.includes("webpack"))return e.respondWith(createResponse(s,t))})),sw.addEventListener("message",(async({data:e})=>{if(e&&"CLIENT_CLOSED"===e.type){const e=await sw.clients.matchAll({includeUncontrolled:!0,type:"window"});e&&e.length&&1!==e.length||sw.registration.unregister()}}));