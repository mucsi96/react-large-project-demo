"use strict";const sw=self;function sendToClient(client,message){return new Promise(resolve=>{const channel=new MessageChannel;channel.port1.onmessage=event=>resolve(event.data),client.postMessage(message,[channel.port2])})}async function createResponse(clientId,request){const getOriginalResponse=()=>fetch(request),client=await sw.clients.get(clientId);if(!client)return getOriginalResponse();const{url:url,method:method}=request,body=await request.text(),headers=getHeaders(request),{type:type,response:response}=await sendToClient(client,{type:"REQUEST",request:{url:url,method:method,body:body,headers:headers}});return"MOCK_SUCCESS"!==type?getOriginalResponse():new Response(response.body,{status:response.status})}function getHeaders(request){const headers={};return request.headers.forEach((value,name)=>{Array.isArray(headers[name])?headers[name]=[...headers[name],value]:headers[name]?headers[name]=[headers[name],value]:headers[name]=value}),headers}sw.addEventListener("install",()=>{sw.skipWaiting()}),sw.addEventListener("activate",event=>{event.waitUntil(sw.clients.claim())}),sw.addEventListener("fetch",event=>{const{request:request,clientId:clientId}=event,{cache:cache,mode:mode}=request;if(clientId&&("only-if-cached"!==cache||"same-origin"===mode)&&request.url.startsWith("http")&&!request.url.includes("webpack"))return event.respondWith(createResponse(clientId,request))}),sw.addEventListener("message",async({data:data})=>{if(data&&"CLIENT_CLOSED"===data.type){const clients=await sw.clients.matchAll({includeUncontrolled:!0,type:"window"});clients&&clients.length&&1!==clients.length||sw.registration.unregister()}});